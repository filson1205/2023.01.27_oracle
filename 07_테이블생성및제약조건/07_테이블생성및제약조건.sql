-- DDL (CREATE TABLE) 및 제약조건

-- DDL(Data Definition Language) : 데이터 정의 언어
-- 객체(OBJECT)를 만들고(CREATE), 수정하고(ALTER), 삭제하는(DROP) 구문

-- 테이블 만들기
-- [표현식] : CREATE TABLE 테이블명(컬럼명 자료형(크기), 컬럼명 자료형(크기), ...);

CREATE TABLE MEMBER(
  MEMBER_ID VARCHAR2(20),
  MEMBER_PWD VARCHAR2(20),
  MEMBER_NAME VARCHAR2(20)
);

-- 컬럼에 주석 달기
-- [표현식] : COMMENT ON COLUMN 테이블명.컬럼명 IS '주석내용';
COMMENT ON COLUMN MEMBER.MEMBER_ID IS '회원아이디';
COMMENT ON COLUMN MEMBER.MEMBER_PWD IS '비밀번호';
COMMENT ON COLUMN MEMBER.MEMBER_NAME IS '회원이름';

SELECT
       M.*
  FROM MEMBER M;

SELECT
       UT.*
  FROM USER_TABLES UT;

SELECT
       UTC.*
  FROM USER_TAB_COLUMNS UTC
 WHERE UTC.TABLE_NAME = 'MEMBER';
 
DESC MEMBER;

-- 제약조건
-- 테이블 정의 시 각 컬럼에 대해 값을 넣을 수 있는 조건을 설정할 수 있다.
-- 데이터 무결성 보장을 목적으로 한다.
-- PRIMARY KEY, NOT NULL, UNIQUE, CHECK, FOREIGN KEY

-- NOT NULL : 해당 컬럼에 NULL값을 허용하지 않는 제약조건
--            컬럼레벨에서 제한
CREATE TABLE USER_NOCONS(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20),
  USER_PWD VARCHAR2(30),
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50)
);

INSERT
  INTO USER_NOCONS
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL
)
VALUES
(
  1, 'user01', 'pass01'
, '홍길동', '남', '010-1234-5678'
, 'hong123@greedy.com'
);

INSERT
  INTO USER_NOCONS
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL
)
VALUES
(
  2, NULL, NULL
, NULL, NULL, '010-1234-5678'
, 'hong123@gmail.com'
);

CREATE TABLE USER_NOTNULL(
  USER_NO NUMBER NOT NULL,
  USER_ID VARCHAR2(20) NOT NULL,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30) NOT NULL,
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50)
);

INSERT
  INTO USER_NOTNULL
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL
)
VALUES
(
  1, 'user01', 'pass01'
, NULL, NULL, '010-1234-5678'
, 'hong123@greedy.com'
);

SELECT
       UN.*
  FROM USER_NOTNULL UN;

SELECT
       UC.*
  FROM USER_CONSTRAINTS UC;

SELECT
       UCC.*
  FROM USER_CONS_COLUMNS UCC;

-- 데이터 딕셔너리 조회
-- 데이터 딕셔너리란?
-- 데이터 사전 이라고 불린다. (데이터에 의한 데이터 -> 메타데이터)
-- DDL 구문을 이용해서 데이터의 구조를 정의, 수정, 삭제할 시 자동으로 반영되는 뷰(가상 테이블)
-- 딕셔너리 뷰는 조회만 가능하다.
-- 1. USER_XXX
-- 2. DBA_XXX
-- 3. ALL_XXX
SELECT
       UC.*
     , UCC.*
  FROM USER_CONSTRAINTS UC
  JOIN USER_CONS_COLUMNS UCC ON(UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME)
 WHERE UC.TABLE_NAME = 'USER_NOTNULL';

-- UNIQUE 제약조건 : 컬럼 입력값에 대해 기존에 존재하는 값과 중복된 값이 들어갈 수 없도록 제한을 거는 제약조건
--                  컬럼 레벨에서 설정 가능, 테이블 레벨에서 설정 가능
SELECT 
       UN.*
  FROM USER_NOCONS UN;

INSERT
  INTO USER_NOCONS
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL
)
VALUES
(
  1, 'user01', 'pass01'
, '홍길동', '남', '010-1234-5678'
, 'hong123@greedy.com'
);

CREATE TABLE USER_UNIQUE(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20) UNIQUE NOT NULL,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50)
);

INSERT
  INTO USER_UNIQUE
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL
)
VALUES
(
  1, 'user01', 'pass01'
, '홍길동', '남', '010-1234-5678'
, 'hong123@greedy.com'
);

INSERT
  INTO USER_UNIQUE
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL
)
VALUES
(
  1, 'user01', 'pass01'
, '홍길동', '남', '010-1234-5678'
, 'hong123@greedy.com'
);

SELECT
       UCC.TABLE_NAME
     , UCC.COLUMN_NAME
     , UC.CONSTRAINT_TYPE
  FROM USER_CONSTRAINTS UC
     , USER_CONS_COLUMNS UCC
 WHERE UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME
   AND UCC.CONSTRAINT_NAME = 'SYS_C008368';

CREATE TABLE USER_UNIQUE2(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20) NOT NULL,
  USER_PWD VARCHAR2(30) NOT NULL, 
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  UNIQUE(USER_ID)
);

CREATE TABLE USER_UNIQUE3(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20) NOT NULL,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  UNIQUE(USER_NO, USER_ID)
);

-- 제약조건에 이름 설정
CREATE TABLE CONS_NAME(
  TEST_DATA1 VARCHAR2(20) CONSTRAINT NN_TEST_DATA1 NOT NULL,
  TEST_DATA2 VARCHAR2(20) CONSTRAINT UN_TEST_DATA2 UNIQUE,
  TEST_DATA3 VARCHAR2(20),
  CONSTRAINT UN_TEST_DATA3 UNIQUE(TEST_DATA3)
);

-- CHECK 제약조건 : 컬럼에 들어가는 값에 비교연산을 이용해 조건을 만족하는 경우에만 값이 들어갈 수 있도록 제한하는 제약조건
CREATE TABLE USER_CHECK(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20) UNIQUE,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10) CHECK(GENDER IN('남', '여')),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50)
);

INSERT
  INTO USER_CHECK
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL
)
VALUES
(
  1, 'user01', 'pass01'
, '홍길동', '남', '010-1234-5678'
, 'hong123@greedy.com'
);

INSERT
  INTO USER_CHECK
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL
)
VALUES
(
  1, 'user02', 'pass02'
, '홍길동', '남자', '010-1234-5678'
, 'hong123@greedy.com'
);

-- PRIMARY KEY(기본키) 제약조건
-- : 주식별자 역할을 수행하는 컬럼에 적용하는 제약조건이다.
--   테이블당 한 개의 기본키 제약조건은 필수이다.
--   테이블당 한 개의 기본키 제약조건만 설정할 수 있다.
--   한 개 컬럼에 설정할 수 도 있고(단일키), 여러 개의 컬럼을 묶어서 설정할 수 도 있다(복합키).
--   기본키 제약조건이 설정되면 묵시적으로 NOT NULL + UNIQUE의 의미를 가진다.
--   기본키 제약조건이 설정되면 자동으로 해당 컬럼에 대한 인덱스가 생성된다.
CREATE TABLE USER_PRIMARYKEY(
  USER_NO NUMBER CONSTRAINT PK_USER_NO PRIMARY KEY,
  USER_ID VARCHAR2(20) UNIQUE,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50)
);

INSERT
  INTO USER_PRIMARYKEY
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL
)
VALUES
(
  1, 'user01', 'pass01'
, '홍길동', '남', '010-1234-5678'
, 'hong123@greedy.com'
);

INSERT
  INTO USER_PRIMARYKEY
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL
)
VALUES
(
  NULL, 'user01', 'pass01'
, '홍길동', '남', '010-1234-5678'
, 'hong123@greedy.com'
);

SELECT
       UC.TABLE_NAME
     , UCC.COLUMN_NAME
     , UC.CONSTRAINT_NAME
     , UC.CONSTRAINT_TYPE
  FROM USER_CONSTRAINTS UC
  JOIN USER_CONS_COLUMNS UCC ON(UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME)
 WHERE UC.CONSTRAINT_NAME = 'PK_USER_NO';

CREATE TABLE USER_PRIMARYKEY2(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20),
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  CONSTRAINT PK_USER_NO2 PRIMARY KEY(USER_NO, USER_ID)
);

SELECT
       UC.TABLE_NAME
     , UCC.COLUMN_NAME
     , UC.CONSTRAINT_NAME
     , UC.CONSTRAINT_TYPE
  FROM USER_CONSTRAINTS UC
  JOIN USER_CONS_COLUMNS UCC ON(UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME)
 WHERE UC.CONSTRAINT_NAME = 'PK_USER_NO2';

-- FOREIGN KEY(외부키/외래키/참조무결성 제약조건) : 
-- 참조(REFERENCES)된 다른 테이블에서 제공하는 값만 사용할 수 있음
-- 참조 무결성을 위배하지 않게 하기 위해 사용한다.
-- FOREIGN KEY제약조건에 의해서 테이블간의 관계(RELATIONSHIP)가 형성된다.
-- 제공되는 값 외에는 NULL을 사용할 수 있다.
-- 선행해서 데이터가 들어가야 하는 테이블을 부모테이블, 나중에 참조하여 데이터를 넣는 테이블을 자식테이블이라고 한다.

-- 컬럼 레벨인 경우
-- 컬럼명 자료형(크기) [CONSTRAINT 제약조건이름] REFERENCES 참조할테이블명 [(참조할컬럼)] [삭제룰]

-- 테이블 레벨인 경우
-- [CONSTRAINT 이름] FOREIGN KEY (적용할컬럼명) REFERENCES 참조할테이블명 [(참조할컬럼)] [삭제룰]

-- 참조할 테이블의 참조할 컬럼명이 생략되면 PRIMARY KEY로 설정된 컬럼이 자동으로 참조할 컬럼이 된다.
-- 참조될 수 있는 컬럼은 PRIMARY KEY 컬럼과 UNIQUE 컬럼만 외래키로 참조할 수 있다.
CREATE TABLE USER_GRADE(
  GRADE_CODE NUMBER PRIMARY KEY,
  GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE (GRADE_CODE, GRADE_NAME) VALUES (10, '일반회원');
INSERT INTO USER_GRADE (GRADE_CODE, GRADE_NAME) VALUES (20, '우수회원');
INSERT INTO USER_GRADE (GRADE_CODE, GRADE_NAME) VALUES (30, '특별회원');

SELECT * FROM USER_GRADE;

COMMIT;

CREATE TABLE USER_FOREIGNKEY(
  USER_NO NUMBER PRIMARY KEY,
  USER_ID VARCHAR2(20) UNIQUE,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  GRADE_CODE NUMBER,
  CONSTRAINT FK_GRADE_CODE FOREIGN KEY (GRADE_CODE) REFERENCES USER_GRADE (GRADE_CODE)
);

INSERT INTO USER_FOREIGNKEY VALUES (1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678', 'hong123@gmail.com', 10);
INSERT INTO USER_FOREIGNKEY VALUES (2, 'user02', 'pass02', '이순신', '남', '010-1234-2222', 'lee123@gmail.com', 10);
INSERT INTO USER_FOREIGNKEY VALUES (3, 'user03', 'pass03', '유관순', '여', '010-1234-3131', 'yoo123@gmail.com', 30);
INSERT INTO USER_FOREIGNKEY VALUES (4, 'user04', 'pass04', '안중근', '남', '010-1234-1111', 'ahn123@gmail.com', null);
INSERT INTO USER_FOREIGNKEY VALUES (5, 'user05', 'pass05', '임꺽정', '남', '010-1234-2222', 'leem123@gmail.com', 50);

COMMIT;

SELECT
       UC.TABLE_NAME
     , UCC.COLUMN_NAME
     , UC.CONSTRAINT_NAME
     , UC.CONSTRAINT_TYPE
  FROM USER_CONSTRAINTS UC
     , USER_CONS_COLUMNS UCC
 WHERE UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME
   AND UC.CONSTRAINT_NAME = 'FK_GRADE_CODE';
   
-- 회원 아이디, 이름, 성별, 연락처, 회원등급명 조회
SELECT
       UF.USER_ID
     , UF.USER_NAME
     , UF.GENDER
     , UF.PHONE
     , UG.GRADE_NAME
  FROM USER_FOREIGNKEY UF
NATURAL LEFT JOIN USER_GRADE UG;
   
-- 삭제 옵션
-- : 부모 테이블의 데이터 삭제 시 자식 테이블의 데이터를 어떤 식으로 처리할 지에 대한 내용을 설정하는 옵션
-- ON DELETE RESTRICT : 참조되고 있는 값 삭제 불가 (기본값)
-- ON DELETE SET NULL : 참조하고 있는 행 삭제 시 참조하는 컬럼을 NULL로 변경
-- ON DELETE CASCADE : 참조하고 있는 행 삭제 시 참조하는 컬럼을 가진 행 삭제

COMMIT;

DELETE 
  FROM USER_GRADE
 WHERE GRADE_CODE = 10;

DELETE 
  FROM USER_GRADE
 WHERE GRADE_CODE = 20;
 
SELECT
       UG.*
  FROM USER_GRADE UG;

ROLLBACK;

CREATE TABLE USER_GRADE2(
  GRADE_CODE NUMBER PRIMARY KEY,
  GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE2 (GRADE_CODE, GRADE_NAME) VALUES (10, '일반회원');
INSERT INTO USER_GRADE2 (GRADE_CODE, GRADE_NAME) VALUES (20, '우수회원');
INSERT INTO USER_GRADE2 (GRADE_CODE, GRADE_NAME) VALUES (30, '특별회원');

SELECT * FROM USER_GRADE2;

CREATE TABLE USER_FOREIGNKEY2(
  USER_NO NUMBER PRIMARY KEY,
  USER_ID VARCHAR2(20) UNIQUE,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  GRADE_CODE NUMBER,
  CONSTRAINT FK_GRADE_CODE2 FOREIGN KEY (GRADE_CODE)
  REFERENCES USER_GRADE2 (GRADE_CODE) ON DELETE SET NULL
);

INSERT INTO USER_FOREIGNKEY2 VALUES (1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678', 'hong123@gmail.com', 10);
INSERT INTO USER_FOREIGNKEY2 VALUES (2, 'user02', 'pass02', '이순신', '남', '010-1234-2222', 'lee123@gmail.com', 10);
INSERT INTO USER_FOREIGNKEY2 VALUES (3, 'user03', 'pass03', '유관순', '여', '010-1234-3131', 'yoo123@gmail.com', 30);
INSERT INTO USER_FOREIGNKEY2 VALUES (4, 'user04', 'pass04', '안중근', '남', '010-1234-1111', 'ahn123@gmail.com', null);

SELECT * FROM USER_FOREIGNKEY2;

DELETE FROM USER_GRADE2 WHERE GRADE_CODE = 10;

SELECT * FROM USER_GRADE2;

-- ON DELETE CASCADE
CREATE TABLE USER_GRADE3(
  GRADE_CODE NUMBER PRIMARY KEY,
  GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE3 (GRADE_CODE, GRADE_NAME) VALUES (10, '일반회원');
INSERT INTO USER_GRADE3 (GRADE_CODE, GRADE_NAME) VALUES (20, '우수회원');
INSERT INTO USER_GRADE3 (GRADE_CODE, GRADE_NAME) VALUES (30, '특별회원');

SELECT * FROM USER_GRADE3;

CREATE TABLE USER_FOREIGNKEY3(
  USER_NO NUMBER PRIMARY KEY,
  USER_ID VARCHAR2(20) UNIQUE,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  GRADE_CODE NUMBER,
  CONSTRAINT FK_GRADE_CODE3 FOREIGN KEY (GRADE_CODE)
  REFERENCES USER_GRADE3 (GRADE_CODE) ON DELETE CASCADE
);

INSERT INTO USER_FOREIGNKEY3 VALUES (1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678', 'hong123@gmail.com', 10);
INSERT INTO USER_FOREIGNKEY3 VALUES (2, 'user02', 'pass02', '이순신', '남', '010-1234-2222', 'lee123@gmail.com', 10);
INSERT INTO USER_FOREIGNKEY3 VALUES (3, 'user03', 'pass03', '유관순', '여', '010-1234-3131', 'yoo123@gmail.com', 30);
INSERT INTO USER_FOREIGNKEY3 VALUES (4, 'user04', 'pass04', '안중근', '남', '010-1234-1111', 'ahn123@gmail.com', null);

SELECT * FROM USER_FOREIGNKEY3;

DELETE FROM USER_GRADE3 WHERE GRADE_CODE = 10;

CREATE TABLE EMPLOYEE_COPY
AS
SELECT E.*
  FROM EMPLOYEE E;
  
SELECT * FROM EMPLOYEE_COPY;

-- 제약조건 추가
-- ALTER TABLE 테이블명 ADD PRIMARY KEY (컬럼명);
-- ALTER TABLE 테이블명 ADD FOREIGN KEY (컬럼명) REFERENCES 테이블명 (컬럼명);
-- ALTER TABLE 테이블명 ADD UNIQUE (컬럼명);
-- ALTER TABLE 테이블명 ADD CHECK (조건);
-- ALTER TABLE 테이블명 MODIFY 컬럼명 [NOT] NULL;
ALTER TABLE EMPLOYEE_COPY ADD PRIMARY KEY(EMP_ID);
ALTER TABLE EMPLOYEE_COPY MODIFY EMP_NAME NOT NULL;

ALTER TABLE DEPARTMENT ADD PRIMARY KEY (DEPT_ID);

-- 실습
-- EMPLOYEE 테이블의 DEPT_CODE에 외래키 제약조건 추가
-- 참조 테이블은 DEPARTMENT, 참조할 컬럼은 DEPARTMENT의 기본키
-- DEPARTMENT 테이블의 LOCATION_ID에 외래키 제약조건 추가
-- 참조 테이블은 LOCATION, 참조 컬럼은 LOCATION의 기본키
-- EMPLOYEE 테이블의 JOB_CODE에 외래키 제약조건 추가
-- 참조 테이블은 JOB 테이블, 참조 컬럼은 JOB 테이블의 기본키
-- EMPLOYEE 테이블의 SAL_LEVEL에 외래키 제약조건 추가
-- 참조 테이블은 SAL_GRADE 테이블, 참조 컬럼은 SAL_GRADE 테이블의 기본키
-- EMPLOYEE 테이블의 ENT_YN 컬럼에 CHECK제약조건 추가 ('Y', 'N')
-- 단, 대소문자를 구분하기 때문에 대문자로 설정할 것
-- EMPLOYEE 테이블의 SALARY 컬럼에 CHECK제약조건 추가(양수)
-- EMPLOYEE 테이블의 EMP_NO 컬럼에 UNIQUE 제약조건 추가

ALTER TABLE EMPLOYEE ADD FOREIGN KEY (DEPT_CODE) REFERENCES DEPARTMENT (DEPT_ID);
ALTER TABLE DEPARTMENT ADD FOREIGN KEY (LOCATION_ID) REFERENCES LOCATION (LOCAL_CODE);
ALTER TABLE EMPLOYEE ADD FOREIGN KEY (JOB_CODE) REFERENCES JOB (JOB_CODE);
ALTER TABLE EMPLOYEE ADD FOREIGN KEY (SAL_LEVEL) REFERENCES SAL_GRADE (SAL_LEVEL);
ALTER TABLE EMPLOYEE ADD CHECK (ENT_YN IN ('Y', 'N'));
ALTER TABLE EMPLOYEE ADD CHECK (SALARY > 0);
ALTER TABLE EMPLOYEE ADD UNIQUE (EMP_NO);













